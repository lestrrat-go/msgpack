package main

import (
	"bytes"
	"fmt"
	"io"
	"log"
	"os"
	"reflect"
	"sort"

	"github.com/lestrrat-go/msgpack/internal/util"
	"github.com/pkg/errors"
)

type argument struct {
	name string
	typ  string
}
type numericType struct {
	Code     string
	Bits     int
	Unsigned bool
}

var floatTypes = map[reflect.Kind]numericType{
	reflect.Float32: {Code: "Float", Bits: 32},
	reflect.Float64: {Code: "Double", Bits: 64},
}
var integerTypes = map[reflect.Kind]numericType{
	reflect.Int:    {Code: "Int64", Bits: 64},
	reflect.Int8:   {Code: "Int8", Bits: 8},
	reflect.Int16:  {Code: "Int16", Bits: 16},
	reflect.Int32:  {Code: "Int32", Bits: 32},
	reflect.Int64:  {Code: "Int64", Bits: 64},
	reflect.Uint:   {Code: "Uint64", Bits: 64, Unsigned: true},
	reflect.Uint8:  {Code: "Uint8", Bits: 8, Unsigned: true},
	reflect.Uint16: {Code: "Uint16", Bits: 16, Unsigned: true},
	reflect.Uint32: {Code: "Uint32", Bits: 32, Unsigned: true},
	reflect.Uint64: {Code: "Uint64", Bits: 64, Unsigned: true},
}

func main() {
	if err := _main(); err != nil {
		log.Printf("%s", err)
		os.Exit(1)
	}
}

func _main() error {
	if err := generateNumericDecoders(); err != nil {
		return errors.Wrap(err, `failed to generate numeric decoders`)
	}

	if err := generateLockingWrappers(); err != nil {
		return errors.Wrap(err, `failed to generate locking wrappers`)
	}
	return nil
}

func writeLockingWrapper(dst io.Writer, methodName string, args []argument, rets []string) error {
	fmt.Fprintf(dst, "\n\nfunc (d *decoder) %s(", methodName)
	for i, arg := range args {
		fmt.Fprintf(dst, "%s %s", arg.name, arg.typ)
		if i != len(args)-1 {
			fmt.Fprint(dst, ", ")
		}
	}
	fmt.Fprint(dst, ") ")

	if len(rets) > 1 {
		fmt.Fprint(dst, "(")
	}
	for i, ret := range rets {
		fmt.Fprint(dst, ret)
		if i != len(rets)-1 {
			fmt.Fprint(dst, ", ")
		}
	}
	if len(rets) > 1 {
		fmt.Fprint(dst, ")")
	}
	fmt.Fprint(dst, " {")
	fmt.Fprintf(dst, "\nd.mu.RLock()")
	fmt.Fprintf(dst, "\ndefer d.mu.RUnlock()")
	fmt.Fprintf(dst, "\nreturn d.nl.%s(", methodName)
	for i, arg := range args {
		fmt.Fprint(dst, arg.name)
		if i != len(args)-1 {
			fmt.Fprint(dst, ", ")
		}
	}
	fmt.Fprint(dst, ")")

	fmt.Fprintf(dst, "\n}")
	return nil
}

func generateLockingWrappers() error {
	var dst = &bytes.Buffer{}

	dst.WriteString("package msgpack")
	dst.WriteString("\n\n// Auto-generated by internal/cmd/gendecoder/gendecoder.go. DO NOT EDIT!")
	dst.WriteString("\n\nimport (")
	dst.WriteString("\n\"reflect\"")
	dst.WriteString("\n\"time\"")
	dst.WriteString("\n)")

	wrappers := []struct {
		name string
		args []argument
		rets []string
	}{
		{
			name: "Decode",
			args: []argument{
				{name: "v", typ: "interface{}"},
			},
			rets: []string{"error"},
		},
		{
			name: "DecodeArray",
			args: []argument{
				{name: "v", typ: "interface{}"},
			},
			rets: []string{"error"},
		},
		{
			name: "DecodeArrayLength",
			args: []argument{
				{name: "v", typ: "*int"},
			},
			rets: []string{"error"},
		},
		{
			name: "DecodeBool",
			args: []argument{
				{name: "v", typ: "*bool"},
			},
			rets: []string{"error"},
		},
		{
			name: "DecodeBytes",
			args: []argument{
				{name: "v", typ: "*[]byte"},
			},
			rets: []string{"error"},
		},
		{
			name: "DecodeExt",
			args: []argument{
				{name: "v", typ: "DecodeMsgpacker"},
			},
			rets: []string{"error"},
		},
		{
			name: "DecodeExtLength",
			args: []argument{
				{name: "v", typ: "*int"},
			},
			rets: []string{"error"},
		},
		{
			name: "DecodeExtType",
			args: []argument{
				{name: "v", typ: "*reflect.Type"},
			},
			rets: []string{"error"},
		},
		{
			name: "DecodeMap",
			args: []argument{
				{name: "v", typ: "*map[string]interface{}"},
			},
			rets: []string{"error"},
		},
		{
			name: "DecodeMapLength",
			args: []argument{
				{name: "v", typ: "*int"},
			},
			rets: []string{"error"},
		},
		{
			name: "DecodeNil",
			args: []argument{
				{name: "v", typ: "*interface{}"},
			},
			rets: []string{"error"},
		},
		{
			name: "DecodeString",
			args: []argument{
				{name: "v", typ: "*string"},
			},
			rets: []string{"error"},
		},
		{
			name: "DecodeStruct",
			args: []argument{
				{name: "v", typ: "interface{}"},
			},
			rets: []string{"error"},
		},
		{
			name: "DecodeTime",
			args: []argument{
				{name: "v", typ: "*time.Time"},
			},
			rets: []string{"error"},
		},
		{
			name: "PeekCode",
			rets: []string{"Code", "error"},
		},
		{
			name: "ReadCode",
			rets: []string{"Code", "error"},
		},
		{
			name: "Reader",
			rets: []string{"Reader"},
		},
	}

	for _, w := range wrappers {
		writeLockingWrapper(dst, w.name, w.args, w.rets)
	}
	// numeric stuff
	keys := make([]reflect.Kind, 0, len(integerTypes)+len(floatTypes))
	for k := range integerTypes {
		keys = append(keys, k)
	}
	for k := range floatTypes {
		keys = append(keys, k)
	}

	sort.Slice(keys, func(i, j int) bool {
		return uint(keys[i]) < uint(keys[j])
	})

	for _, typ := range keys {
		writeLockingWrapper(
			dst,
			fmt.Sprintf("Decode%s", util.Ucfirst(typ.String())),
			[]argument{
				{name: "v", typ: "*" + typ.String()},
			},
			[]string{"error"},
		)
	}

	if err := util.WriteFormattedFile("decoder_locking_gen.go", dst.Bytes()); err != nil {
		return errors.Wrap(err, `failed to write to file`)
	}
	return nil
}

func generateNumericDecoders() error {

	var buf bytes.Buffer

	buf.WriteString("package msgpack")
	buf.WriteString("\n\n// Auto-generated by internal/cmd/gendecoder/gendecoder.go. DO NOT EDIT!")
	buf.WriteString("\n\nimport (")
	buf.WriteString("\n\"math\"")
	buf.WriteString("\n\n\"github.com/pkg/errors\"")
	buf.WriteString("\n)")

	if err := generateIntegerTypes(&buf); err != nil {
		return errors.Wrap(err, `failed to generate integer decoders`)
	}

	if err := generateFloatTypes(&buf); err != nil {
		return errors.Wrap(err, `failed to generate float decoders`)
	}

	if err := util.WriteFormattedFile("decoder_numeric_gen.go", buf.Bytes()); err != nil {
		return errors.Wrap(err, `failed to write to file`)
	}
	return nil
}

func generateIntegerTypes(dst io.Writer) error {
	types := integerTypes

	keys := make([]reflect.Kind, 0, len(types))
	for k := range types {
		keys = append(keys, k)
	}
	sort.Slice(keys, func(i, j int) bool {
		return uint(keys[i]) < uint(keys[j])
	})
	for _, typ := range keys {
		data := types[typ]
		fmt.Fprintf(dst, "\n\nfunc (d *decoderNL) Decode%s(v *%s) error {", util.Ucfirst(typ.String()), typ)
		fmt.Fprintf(dst, "\ncode, err := d.src.ReadByte()")
		fmt.Fprintf(dst, "\nif err != nil {")
		fmt.Fprintf(dst, "\nreturn errors.Wrap(err, `msgpack: failed to read code for %s`)", data.Code)
		fmt.Fprintf(dst, "\n}")
		fmt.Fprintf(dst, "\nif IsFixNumFamily(Code(code)) {")
		fmt.Fprintf(dst, "\n*v = %s(code)", typ)
		fmt.Fprintf(dst, "\nreturn nil")
		fmt.Fprintf(dst, "\n}")
		// We need to allow numbers with lower bit sizes that fit in this type
		var baseName string
		if data.Unsigned {
			baseName = "Uint"
		} else {
			baseName = "Int"
		}
		fmt.Fprintf(dst, "\nswitch Code(code) {")
		for size := data.Bits; size >= 8; size /= 2 {
			fmt.Fprintf(dst, "\ncase %s%d:", baseName, size)
			fmt.Fprintf(dst, "\nx, err := d.src.ReadUint%d()", size)
			fmt.Fprintf(dst, "\nif err != nil {")
			fmt.Fprintf(dst, "\nreturn errors.Wrap(err, `msgpack: failed to read payload for %s`)", typ)
			fmt.Fprintf(dst, "\n}")
			fmt.Fprintf(dst, "\n*v = %s(x)", typ)
			fmt.Fprintf(dst, "\nreturn nil")
		}
		fmt.Fprintf(dst, "\n}") // end switch Code(code)
		fmt.Fprintf(dst, "\nreturn errors.Errorf(`msgpack: invalid numeric type %%s for %s`, Code(code))", typ)
		fmt.Fprintf(dst, "\n}")
	}
	return nil
}

func generateFloatTypes(dst io.Writer) error {
	types := floatTypes

	keys := make([]reflect.Kind, 0, len(types))
	for k := range types {
		keys = append(keys, k)
	}
	sort.Slice(keys, func(i, j int) bool {
		return uint(keys[i]) < uint(keys[j])
	})
	for _, typ := range keys {
		data := types[typ]

		fmt.Fprintf(dst, "\n\nfunc (d *decoderNL) Decode%s(v *%s) error {", util.Ucfirst(typ.String()), typ)
		fmt.Fprintf(dst, "\ncode, x, err := d.src.ReadByteUint%d()", data.Bits)
		fmt.Fprintf(dst, "\nif err != nil {")
		fmt.Fprintf(dst, "\nreturn errors.Wrap(err, `msgpack: failed to read %s`)", typ)
		fmt.Fprintf(dst, "\n}")
		fmt.Fprintf(dst, "\n\nif code != %s.Byte() {", data.Code)
		fmt.Fprintf(dst, "\nreturn errors.Errorf(`msgpack: expected %s, got %%s`, Code(code))", data.Code)
		fmt.Fprintf(dst, "\n}")
		fmt.Fprintf(dst, "\n\n*v = math.Float%dfrombits(x)", data.Bits)
		fmt.Fprintf(dst, "\nreturn nil")
		fmt.Fprintf(dst, "\n}")
	}
	return nil
}
